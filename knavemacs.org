#+TITLE: Knavemacs Emacs Configuration
#+AUTHOR: John Osinski
#+EMAIL: johnosinski80@gmail.com
#+DATE: [2024-07-26 Fri 15:25]

:  ___  __    ________   ________  ___      ___ _______   _____ ______   ________  ________  ________
: |\  \|\  \ |\   ___  \|\   __  \|\  \    /  /|\  ___ \ |\   _ \  _   \|\   __  \|\   ____\|\   ____\
: \ \  \/  /|\ \  \\ \  \ \  \|\  \ \  \  /  / | \   __/|\ \  \\\__\ \  \ \  \|\  \ \  \___|\ \  \___|
:  \ \   ___  \ \  \\ \  \ \   __  \ \  \/  / / \ \  \_|/_\ \  \\|__| \  \ \   __  \ \  \    \ \_____  \
:   \ \  \\ \  \ \  \\ \  \ \  \ \  \ \    / /   \ \  \_|\ \ \  \    \ \  \ \  \ \  \ \  \____\|____|\  \
:    \ \__\\ \__\ \__\\ \__\ \__\ \__\ \__/ /     \ \_______\ \__\    \ \__\ \__\ \__\ \_______\____\_\  \
:     \|__| \|__|\|__| \|__|\|__|\|__|\|__|/       \|_______|\|__|     \|__|\|__|\|__|\|_______|\_________\
:                                                                                              \|_________|

* What is this?
This is my [[https://www.gnu.org/software/emacs/][GNU Emacs]] configuration using an org file. ~knavemacs.org~ is the
core configuration file that defines the behavior, packages, and settings used
in my custom emacs setup. While this org file is the "engine", the other
important file for my setup is the included ~config.el~ file. This file is the
"brains" so to speak. For each package configured in my knavemacs.org file,
there are variables that are being checked to determine if that package should
actually be loaded. These variables are set in the config.org file.

The variables setup in the config.org file allow me to define different
combinations of these variables for the various devices that I use my emacs
configuration on. I call these "device profiles", which are setup as elisp
functions, which in-turn set various variables that define which packages should
be loaded on my device. I encourage you to take a look at the config.el file to
understand how it influences which parts of knavemace.org get loaded.

This brings me to how to load this config!  For your own emacs instance, you can
add the following lines to your ~.emacs~ or ~.config/emacs/init.el~ file (the
below is assuming that you are putting config.el and knavemacs.org files in the
~/.config/emacs folder):

: (require 'org)
: (require 'ob-tangle)
: (setq knavemacs/device-profile 'computer)
: (load "~/.config/emacs/config.el")
: (org-babel-load-file "~/.config/emacs/knavemacs.org")

The first two lines above initalize org and ob-tangle which will allow the
elisp blocks in knavemacs.org to be loaded as if they were part of a singluar
.emacs configuration file. The third line sets my "device profile" variable
to a specific value. This is important for the fourth line, which loads
the config.el file - this file runs a function based on the value of the
device-profile variable, and that function sets certain variables which tell
knavemacs.org which packages to load for that specific device. The actual
loading of the contents of knavemacs.org is done with the last line above.

To run my configuration of emacs, some dependencies must be met. These are
listed in the next section.

Credit should be given where credit is due. Much of this config is heavily
inspired (and sometimes copied verbatim) from System Crafter's *Emacs From Scratch*
series on youtube. Definitely a must watch.

* Installation
Requirements:
- FiraCode Nerd Font
- Symbols Nerd Font (try 'nerd-icons-install-fonts')
- git
- Directory ~/Shelf/snippets created to load snippet files
- Org Mode Directory Setup - for my org workflow:
  1) Org files go to ~/Documents/org
  2) There should be a =fleeting.org=, =unfiled.org=, =notice.org=, and
     =worklog.org= file in the top level org folder.
  3) There should be an =active= and =info= folder in the top level org folder.
     
* Configuration

** Global Environment Settings
*** Startup Environment Settings

These options configure aspects about how my Emacs environment shoudl
work (e.g. encoding settings, garbage collection, backup file rules etc).

Just a special notes on garbage collection, I've read a lot about
different ways to approach this. I'm going off a stack exchange post
that [[https://emacs.stackexchange.com/question/34342/is-there-any-downside-to-setting-gc-cons-threshold-very-high-and-collecting-ga][you can read here]] with some suggestions on how to set this. I'm
using a single command for now and we'll see how that goes.

#+BEGIN_SRC emacs-lisp
  ;; -*- lexical-binding: t; -*-
  (set-language-environment 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-keyboard-coding-system 'utf-8-unix)
  (set-terminal-coding-system 'utf-8-unix)

  ;; warning level (will change if troubleshooting needed)
  (setq warning-minimum-level :error)

  ;; garbage collection threshold
  (setq gc-cons-threshold (* 1024 1024 100)) ; about 100MB

  ;; cursor setup for non-active windows
  (setq-default cursor-in-non-selected-windows 'hbar)

  ;; GUI specific adjustments
  (setq inhibit-startup-message t) ; no more default start screen
  (setq visible-bell t)            ; stop beeping
  (scroll-bar-mode -1)             ; disable scroll bars
  (tool-bar-mode -1)               ; disable tool bar
  (tooltip-mode -1)                ; disable tooltips
  (menu-bar-mode -1)               ; disable menu bar

  ;; set a default location for backup files
  (if (not (file-exists-p "~/.local/share/emacs-saves"))
      (make-directory "~/.local/share/emacs-saves" t))
  (setq backup-directory-alist '(("." . "~/.local/share/emacs-saves")))
  (setq make-backup-files t
	backup-by-copying t
	version-control t
	delete-old-version t
	delete-by-moving-to-trash t
	kept-old-versions 6
	kept-new-versions 6
	auto-save-default t
	auto-save-timeout 20
	auto-save-interval 200
	)
#+END_SRC

*** Package Manager Setup
This will be needed as this configuration file is read. Setup the package
manager and package repository for these customizations.

#+BEGIN_SRC emacs-lisp
    ;; define package sources and config
    (require 'package)
    (setq package-archives '(("melpa" . "https://melpa.org/packages/")
			     ("org" . "https://orgmode.org/elpa/")
			     ("elpa" . "https://elpa.gnu.org/packages/")
			     ))
    (package-initialize)
    (unless package-archive-contents
      (package-refresh-contents))

    ;; use-package setup
    (unless (package-installed-p 'use-package)
      (package-install 'use-package))
    (require 'use-package)
    (setq use-package-always-ensure t)
#+END_SRC


** Visual Interface
*** Colorscheme
This section probably changes alot :)

#+BEGIN_SRC emacs-lisp
  ;; define the colorscheme
  (use-package doom-themes
    :if knavemacs/config-visual
    :ensure t
    :config
    ; Global settings (defaults)
    (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
	  doom-themes-enable-italic t) ; if nil, italics is universally disabled
    (load-theme 'doom-acario-dark t)

    ;; Enable flashing mode-line on errors
    (doom-themes-visual-bell-config)
      ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config))
#+END_SRC

*** Font Configuration
This section also probably changes alot :)
Depending on the chosen font, I also add capability for ligatures!

#+BEGIN_SRC emacs-lisp
  ;; define the font
  (if (eq knavemacs/config-fonts t) (add-to-list 'default-frame-alist
					       '(font . "FiraCode Nerd Font 12")))

  ;; setup ligatures
  (use-package ligature
    :if knavemacs/config-fonts
    :config
    ;; Enable the "www" ligature in every possible major mode
    (ligature-set-ligatures 't '("www"))
    ;; Enable traditional ligature support in eww-mode, if the
    ;; `variable-pitch' face supports it
    (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
    ;; Enable all Cascadia and Fira Code ligatures in programming modes
    (ligature-set-ligatures 'prog-mode
			    '(;; == === ==== => =| =>>=>=|=>==>> ==< =/=//=// =~
			      ;; =:= =!=
			      ("=" (rx (+ (or ">" "<" "|" "/" "~" ":" "!" "="))))
			      ;; ;; ;;;
			      (";" (rx (+ ";")))
			      ;; && &&&
			      ("&" (rx (+ "&")))
			      ;; !! !!! !. !: !!. != !== !~
			      ("!" (rx (+ (or "=" "!" "\." ":" "~"))))
			      ;; ?? ??? ?:  ?=  ?.
			      ("?" (rx (or ":" "=" "\." (+ "?"))))
			      ;; %% %%%
			      ("%" (rx (+ "%")))
			      ;; |> ||> |||> ||||> |] |} || ||| |-> ||-||
			      ;; |->>-||-<<-| |- |== ||=||
			      ;; |==>>==<<==<=>==//==/=!==:===>
			      ("|" (rx (+ (or ">" "<" "|" "/" ":" "!" "}" "\]"
					      "-" "=" ))))
			      ;; \\ \\\ \/
			      ("\\" (rx (or "/" (+ "\\"))))
			      ;; ++ +++ ++++ +>
			      ("+" (rx (or ">" (+ "+"))))
			      ;; :: ::: :::: :> :< := :// ::=
			      (":" (rx (or ">" "<" "=" "//" ":=" (+ ":"))))
			      ;; // /// //// /\ /* /> /===:===!=//===>>==>==/
			      ("/" (rx (+ (or ">"  "<" "|" "/" "\\" "\*" ":" "!"
					      "="))))
			      ;; .. ... .... .= .- .? ..= ..<
			      ("\." (rx (or "=" "-" "\?" "\.=" "\.<" (+ "\."))))
			      ;; -- --- ---- -~ -> ->> -| -|->-->>->--<<-|
			      ("-" (rx (+ (or ">" "<" "|" "~" "-"))))
			      ;; *> */ *)  ** *** ****
			      ("*" (rx (or ">" "/" ")" (+ "*"))))
			      ;; www wwww
			      ("w" (rx (+ "w")))
			      ;; <> <!-- <|> <: <~ <~> <~~ <+ <* <$ </  <+> <*>
			      ;; <$> </> <|  <||  <||| <|||| <- <-| <-<<-|-> <->>
			      ;; <<-> <= <=> <<==<<==>=|=>==/==//=!==:=>
			      ;; << <<< <<<<
			      ("<" (rx (+ (or "\+" "\*" "\$" "<" ">" ":" "~"  "!"
					      "-"  "/" "|" "="))))
			      ;; >: >- >>- >--|-> >>-|-> >= >== >>== >=|=:=>>
			      ;; >> >>> >>>>
			      (">" (rx (+ (or ">" "<" "|" "/" ":" "=" "-"))))
			      ;; #: #= #! #( #? #[ #{ #_ #_( ## ### #####
			      ("#" (rx (or ":" "=" "!" "(" "\?" "\[" "{" "_(" "_"
					   (+ "#"))))
			      ;; ~~ ~~~ ~=  ~-  ~@ ~> ~~>
			      ("~" (rx (or ">" "=" "-" "@" "~>" (+ "~"))))
			      ;; __ ___ ____ _|_ __|____|_
			      ("_" (rx (+ (or "_" "|"))))
			      ;; Fira code: 0xFF 0x12
			      ("0" (rx (and "x" (+ (in "A-F" "a-f" "0-9")))))
			      ;; Fira code:
			      "Fl"  "Tl"  "fi"  "fj"  "fl"  "ft"
			      ;; The few not covered by the regexps.
			      "{|"  "[|"  "]#"  "(*"  "}#"  "$>"  "^="))
    ;; Enables ligature checks globally in all buffers. You can also do it
    ;; per mode with `ligature-mode'.
    (global-ligature-mode t))
#+END_SRC

*** Line Number Configuration
I set the fill-column amount so that I can automatically wrap
paragraphs using the keybind ~M-q~.  I like to use line numbers on the
left-hand side, and like to have relative (visual!)  line numbers
shown so I know how far apart various lines are from my current cursor
location.

#+BEGIN_SRC emacs-lisp
  ;; set fill column amount and line numbers style
  (setq-default fill-column 80)
  (column-number-mode)

  (defun knavemacs/no-line-nums-hook ()
    (display-line-numbers-mode 0))

  (setq display-line-numbers-type 'visual)
  (global-display-line-numbers-mode t)
  (dolist (mode '(term-mode-hook
		  eshell-mode-hook
		  dired-mode-hook))
    (add-hook mode 'knavemacs/no-line-nums-hook))
#+END_SRC

*** Which Key
Which key is a fantastic interface to inform the user what additional
key-presses will correspond to what actions with a clean, sleak user
interface.

#+BEGIN_SRC emacs-lisp
  ;; which-key configuration
  (use-package which-key
    :if knavemacs/config-visual
    :init (which-key-mode)
    :diminish
    :config
    (setq which-key-idle-delay 1.8))
#+END_SRC

*** Visual Undo
Vundo is a great undo tree visualizer interface.

#+BEGIN_SRC emacs-lisp
  ;; vundo configuration
  (use-package vundo
    :if knavemacs/config-visual
    )
#+END_SRC

*** Fuzzy Finding Framework
Vertico and its ecosystem are unmatched in the area of fuzzy finding completions!
| Vertico        | Minibuffer Completions                                    |
| Savehist       | Most recent prior matches appear on top of list           |
| Marginalia     | Extra information in the margins of vertico completions   |
| Orderless      | Orderless fuzzy finding algorithm                         |
| Embark         | Context menu mini-buffer actions using keys               |
| Consult        | Streamlined, taylored commands using the verico framework |
| Embark-Consult | Connection point between embark and consult               |

#+BEGIN_SRC emacs-lisp
  ;; PURPOSE: minimal completion system in the likes of helm and ivy
  (use-package vertico
    :if knavemacs/config-fuzzyfind
    :bind (:map vertico-map
                ("C-j" . vertico-next)
                ("C-k" . vertico-previous)
                ("C-f" . vertico-exit)
                :map minibuffer-local-map
                ("C-h" . backward-kill-word))
    :custom
    (vertico-cycle t)
    :init
    (vertico-mode))


  ;; PURPOSE: built in emacs package that works with vertico, show recent completion selections used
  (use-package savehist
    :if knavemacs/config-fuzzyfind
    :init
    (savehist-mode))


  ;; PURPOSE: provides extra metadata in margins of vertico completions
  (use-package marginalia
    :if knavemacs/config-fuzzyfind
    :after vertico
    :custom
    (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    :init
    (marginalia-mode))

  ;; PURPOSE: provides and orderless algorithm for fuzzy finding
  (use-package orderless
    :if knavemacs/config-fuzzyfind
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles basic partial-completion)))))

  ;; PURPOSE: Minibuffer actions based on vertico completions
  (use-package embark
    :if knavemacs/config-fuzzyfind
    :ensure t

    :bind
    (("C-." . embark-act)         ;; pick some comfortable binding
     ("C-;" . embark-dwim)        ;; good alternative: M-.
     ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

    :init

    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)

    ;; Show the Embark target at point via Eldoc.  You may adjust the Eldoc
    ;; strategy, if you want to see the documentation from multiple providers.
    ;; (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
    ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

    :config

    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))


  ;; PURPOSE: provides alternative, taylored commands for various search / switch functions using the current completion framework
  (use-package consult
    :if knavemacs/config-fuzzyfind
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings in `mode-specific-map'
           ("C-c M-x" . consult-mode-command)
           ("C-c h" . consult-history)
           ("C-c k" . consult-kmacro)
           ("C-c m" . consult-man)
           ("C-c i" . consult-info)
           ([remap Info-search] . consult-info)
           ;; C-x bindings in `ctl-x-map'
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
                                          ; ("C-x p b" . consult-project-buffer)    ;; moved to overall key binds section
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ;; M-g bindings in `goto-map'
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings in `search-map'
           ("M-s d" . consult-find)
           ("M-s D" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s L" . consult-line-multi)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
           ;; Minibuffer history
           :map minibuffer-local-map
           ("M-s" . consult-history)                 ;; orig. next-matching-history-element
           ("M-r" . consult-history))                ;; orig. previous-matching-history-element

    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key "M-.")
    ;; (setq consult-preview-key '("S-<down>" "S-<up>"))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key "M-."
     :preview-key '(:debounce 0.4 any))

    ;; Optionally configure the narrowing key.
    ;; Both  and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; "C-+"

    ;; Optionally make narrowing help available in the minibuffer.
    ;; You may want to use `embark-prefix-help-command' or which-key instead.
    ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

    ;; By default `consult-project-function' uses `project-root' from project.el.
    ;; Optionally configure a different project root function.
      ;;;; 1. project.el (the default)
    ;; (setq consult-project-function #'consult--default-project--function)
      ;;;; 2. vc.el (vc-root-dir)
    ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
      ;;;; 3. locate-dominating-file
    ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
      ;;;; 4. projectile.el (projectile-project-root)
    ;; (autoload 'projectile-project-root "projectile")
    ;; (setq consult-project-function (lambda (_) (projectile-project-root)))
      ;;;; 5. No project support
    ;; (setq consult-project-function nil)
    )

  ;; PURPOSE: provides an integration point between embark and consult packages
  (use-package embark-consult
    :if knavemacs/config-fuzzyfind
    )

#+END_SRC

*** Nerd Font Icons
I use the nerd-icons family of packages for consistent nerd icons in GUI and
terminal!

#+BEGIN_SRC emacs-lisp
  ;; PACKAGE: nerd-icons
  ;; PURPOSE: fancy icons in GUI and terminal emacs
  (use-package nerd-icons
    :if knavemacs/config-visual-icons
    )
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; PACKAGE: nerd-icons-dired
  ;; PURPOSE: fancy icons in dired buffers
  (use-package nerd-icons-dired
    :if knavemacs/config-visual-icons
    :after nerd-icons
    :hook
    (dired-mode . nerd-icons-dired-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; PACKAGE: nerd-icons-completion
  ;; PURPOSE: fancy icons in completion buffers
  (use-package nerd-icons-completion
    :if knavemacs/config-visual-icons
    :after vertico marginalia nerd-icons
    :config
    (nerd-icons-completion-mode)
    (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; PACKAGE: nerd-icons-ibuffer
  ;; PURPOSE: fancy icons in ibuffer
  (use-package nerd-icons-ibuffer
    :if knavemacs/config-visual-icons
    :after nerd-icons
    :hook (ibuffer-mode . nerd-icons-ibuffer-mode))
#+END_SRC

*** Mode Line Configuration
I wrote my own mode-line. First I have functions that provide font face
configuration. Following that is the actual mode-line definition.

#+BEGIN_SRC emacs-lisp
  ;; Start with the faces for the meow mode indicator
  (defface knavemacs/face-meow-normal
    '((t :foreground "#bcbcbc"
	 ))
    "Face for Normal Mode"
    :group 'knavemacs/mode-line-faces)

  (defface knavemacs/face-meow-insert
    '((t :foreground "#66CC22"
	 :weight bold
	 ))
    "Face for Insert Mode"
    :group 'knavemacs/mode-line-faces)

  (defface knavemacs/face-meow-keypad
    '((t :foreground "#aa0066"
	 :background "#090909"
	 :weight bold
	 ))
    "Face for keypad Mode"
    :group 'knavemacs/mode-line-faces)

  (defface knavemacs/face-meow-motion
    '((t :foreground "#b57123"
	 ))
    "Face for motion Mode"
    :group 'knavemacs/mode-line-faces)

  (defface knavemacs/face-meow-beacon
    '((t :foreground "#bb1213"
	 :weight bold
	 ))
    "Face for beacon Mode"
    :group 'knavemacs/mode-line-faces)

  ;; construct the meow mode indicator
  (defun knavemacs/modeline-faces-meow ()
    (cond (meow-normal-mode 'knavemacs/face-meow-normal)
	  (meow-insert-mode 'knavemacs/face-meow-insert)
	  (meow-motion-mode 'knavemacs/face-meow-motion)
	  (meow-keypad-mode 'knavemacs/face-meow-keypad)
	  (meow-beacon-mode 'knavemacs/face-meow-beacon)))

  ;; misc mode line faces
  (defface knavemacs/modeline-faces-readonly
    '((t :foreground "#AA1523"
	 :weight bold
	 ))
    "Face for readonly indicator"
    :group 'knavemacs/mode-line-faces)

  (defface knavemacs/modeline-faces-modified
    '((t :foreground "#d59123"
	 :weight bold
	 ))
    "Face for modified indicator"
    :group 'knavemacs/mode-line-faces)

  (defface knavemacs/modeline-faces-kmacrorec
    '((t :foreground "#AA1122"
	 :weight bold
	 ))
    "Face for kmacro record indicator"
    :group 'knavemacs/mode-line-faces)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; Let's define the modules I will use.

  ;; modeline module: meow indicator
  (defvar-local knavemacs/modeline-meow-indicator
      '(:eval
	(when (mode-line-window-selected-p)
	  (propertize (meow-indicator) 'face (knavemacs/modeline-faces-meow))))
    "Modeline module to provide a meow mode indicator.")

  ;; modeline module: readonly indicator
  (defvar-local knavemacs/modeline-readonly-indicator
      '(:eval
	(when buffer-read-only
	  (propertize "" 'face 'knavemacs/modeline-faces-readonly)))
    "Modeline module to provide a readonly indicator for appropriate buffers")

  ;; modeline module: modified indicator
  (defvar-local knavemacs/modeline-modified-indicator
      '(:eval
	(when (buffer-modified-p)
	  (propertize "" 'face 'knavemacs/modeline-faces-modified)))
    "Modeline module to provide a modified indicator for appropriate buffers")

  ;; modeline module: buffer name
  (defvar-local knavemacs/modeline-bufname
      '(:eval
	(propertize (buffer-name) 'help-echo (buffer-file-name)))
    "Modeline module to provide the buffer name.")

  ;; modeline module: major mode icon
  (defvar-local knavemacs/modeline-major-mode-icon
      '(:eval
	(when (mode-line-window-selected-p)
	  (nerd-icons-icon-for-mode major-mode)))
    "Modeline module to provide an icon based on the major mode.")

  ;; modeline module: major mode name
  (defvar-local knavemacs/modeline-major-mode-name
      '(:eval
	(when (mode-line-window-selected-p)
	  mode-name))
    "Modeline module to provide major mode name.")

  ;; modeline module: right display
  (defvar-local knavemacs/modeline-right-display
      '(""
	" L%l:C%c "
	"[%p]")
    "Modeline module to provide minimal modeline info aligned right.")

  ;; modeline module: kmacro record indicator
  (defvar-local knavemacs/modeline-kmacro-indicator
      '(:eval
	(when defining-kbd-macro
	  (propertize " (󰑋 MACRO)" 'face 'knavemacs/modeline-faces-kmacrorec)))
    "Modeline module to provide an indicator for when recording kmacros")

  ;; making the modeline modules "risky" variables
  (dolist (construct '(knavemacs/modeline-meow-indicator
			knavemacs/modeline-readonly-indicator
			knavemacs/modeline-modified-indicator
			knavemacs/modeline-bufname
			knavemacs/modeline-major-mode-icon
			knavemacs/modeline-major-mode-name
			knavemacs/modeline-right-display
			knavemacs/modeline-kmacro-indicator))
    (put construct 'risky-local-variable t)) ;; required for modeline local vars

  ;; modeline *function*: fill for alignment
  (defun knavemacs/modeline-fill-for-alignment ()
    "Modeline module to provide filler space until right-aligned items on the modeline"
    (let ((r-length (length (concat (format-mode-line knavemacs/modeline-right-display) (format-mode-line knavemacs/modeline-kmacro-indicator)) )))
      (propertize " "
		  'display `(space :align-to (- right ,r-length)))))

  ;; now construct the actual mode-line
  (when (and
	 knavemacs/config-visual-icons
	 knavemacs/config-keybinds
	 knavemacs/config-visual)
    (setq-default mode-line-format
		  '("%e"
		    " "
		    knavemacs/modeline-meow-indicator
		    mode-line-front-space
		    knavemacs/modeline-readonly-indicator
		    " "
		    knavemacs/modeline-modified-indicator
		    " "
		    knavemacs/modeline-bufname
		    " "
		    knavemacs/modeline-major-mode-icon
		    " "
		    knavemacs/modeline-major-mode-name
		    (:eval (knavemacs/modeline-fill-for-alignment))
		    knavemacs/modeline-right-display
		    knavemacs/modeline-kmacro-indicator)))
#+END_SRC

*** Dashboard
I think using dashboard as a starting buffer works well when emacs launches
as a daemon on startup!

#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :if knavemacs/config-visual
    :config
    (dashboard-setup-startup-hook)
    (add-hook 'dashboard-mode-hook (lambda () (setq-local global-hl-line-mode nil)))
    (setq initial-buffer-choice (lambda () (get-buffer-create "*dashboard*")))
    :custom
    (dashboard-banner-ascii "
  ██╗  ██╗███╗   ██╗ █████╗ ██╗   ██╗███████╗███╗   ███╗ █████╗  ██████╗███████╗
  ██║ ██╔╝████╗  ██║██╔══██╗██║   ██║██╔════╝████╗ ████║██╔══██╗██╔════╝██╔════╝
  █████╔╝ ██╔██╗ ██║███████║██║   ██║█████╗  ██╔████╔██║███████║██║     ███████╗
  ██╔═██╗ ██║╚██╗██║██╔══██║╚██╗ ██╔╝██╔══╝  ██║╚██╔╝██║██╔══██║██║     ╚════██║
  ██║  ██╗██║ ╚████║██║  ██║ ╚████╔╝ ███████╗██║ ╚═╝ ██║██║  ██║╚██████╗███████║
  ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝  ╚═══╝  ╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝ ╚═════╝╚══════╝
   ")
    (dashboard-startup-banner 'ascii)
    (dashboard-banner-logo-title nil)
    (dashboard-center-content t)
    (dashboard-icon-type 'nerd-icons)
    (dashboard-set-heading-icons t)
    (dashboard-set-file-icons t)
    (dashboard-set-init-info t)
    (dashboard-set-footer nil)
    (dashboard-projects-backend 'project-el)
    (dashboard-display-icons-p t)
    (dashboard-items '(
		       (recents . 5)
		       (agenda . 5)
		       (projects . 5)
		       (bookmarks . 5)
		       )))
#+END_SRC 

*** Smart Coloration
I use Rainbow Delimiters to denote nested delims with different colors.
I also use Rainbow Mode to highlight hex colors in their respective color
definitions!

#+BEGIN_SRC emacs-lisp
  ;; PACKAGE: rainbow-delimiters
  ;; PURPOSE: make apparent the nested parenthesis in program code like Elisp
  (use-package rainbow-delimiters
    :if knavemacs/config-visual
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; PACKAGE: rainbow-mode
  ;; PURPOSE: provide color highlighting for rgb/hex codes in the buffer
  (use-package rainbow-mode
    :if knavemacs/config-visual
    )
#+END_SRC

*** Tab Line Configuration
Yes I use tab-line tabs, and I am very choosy about how I like the tab line
represented. Below is some elips that is heavily refractored from a script
written by thread314, much credit goes to them for a lot of the structure
and concepts of the below. Their script can be [[https://github.com/thread314/intuitive-tab-line-mode][found here.]] 

#+BEGIN_SRC emacs-lisp
  ;; manually installed elisp script
  ;; Define the function to be used for tab-line management and
  ;; create the buffer list that will be used for holding the tab buffers
  (setq tab-line-tabs-function 'knavemacs/tab-line-buffers)
  (setq knavemacs/tab-line-buffers-list (list (current-buffer)))
  (defun knavemacs/tab-line-buffers ()
    "Provides a list containing buffers to be shown on the tab line"
    knavemacs/tab-line-buffers-list)

  ;; function to add a new tab for a buffer
  (defun knavemacs/tab-line-add-current-buffer ()
    "Adds the current buffer to the list of tabs."
    (interactive)
    (if
        (and
         (not (seq-contains-p knavemacs/tab-line-buffers-list (current-buffer))) ; exclude already added
         (not (string-match (rx "magit") (buffer-name (current-buffer)))) ;; exclude magit buffers
         (not (string-match (rx "COMMIT_EDITMSG") (buffer-name (current-buffer)))) ;; exclude COMMIT buffers
         (not (string-match (rx "CAPTURE-") (buffer-name (current-buffer)))) ;; exclude capture buffers
         (not (string-match (rx "*org-roam*") (buffer-name (current-buffer)))) ;; exclude org-roam buffers
         (not (string-match (rx "*scratch*") (buffer-name (current-buffer)))) ;; exclude *scratch*
         (not (string-match (rx "*Messages*") (buffer-name (current-buffer)))) ;; exclude *Messages*
         (not (string-match (rx "*Mini") (buffer-name (current-buffer)))) ;; exclude mini buffer completions
         (not (string-match (rx "*dashboard*") (buffer-name (current-buffer)))) ;; exclude *dashboard*
         (not (string-match (rx "*eldoc") (buffer-name (current-buffer)))) ;; exclude eldoc buffers
         (not (string-match (rx ".org") (buffer-name (current-buffer)))) ;; exclude org files
         (not (string-match (rx "*Dired") (buffer-name (current-buffer)))) ;; exclude other dired buffers
         (not (string-match (rx "*Completions") (buffer-name (current-buffer)))) ;; exclude completion buffers
         )
        (setq knavemacs/tab-line-buffers-list (append knavemacs/tab-line-buffers-list (list (current-buffer)))))

                                          ; buffer must have a buffer name. Some dired or other system buffers do not have a name, so filter those out
    (setq knavemacs/tab-line-buffers-list (seq-remove (lambda (elt) (not (buffer-name elt))) knavemacs/tab-line-buffers-list)) 
    (set-window-parameter nil 'tab-line-cache nil)
    (force-mode-line-update))

  ;; this function is not called directly, but helps in removing tabs
  (defun knavemacs/tab-line-switch-before-drop-kill ()
    "Switch to another tab, before dropping/killing current buffer (to prevent backgrounded buffers unexpectedly returning to knavemacs/tab-line-buffers-list)."
    (let ((n (seq-position knavemacs/tab-line-buffers-list (current-buffer))))
      (cond
       ((= (length knavemacs/tab-line-buffers-list) 1)
        ;;If only one tab, return error
        (message "Only one tab open, cannot drop"))
       ;;If left most tab, switch right
       ((= n 0)
        (switch-to-buffer (nth 1 knavemacs/tab-line-buffers-list)))
       ;;otherwise switch left
       (t
        (switch-to-buffer (nth (- n 1) knavemacs/tab-line-buffers-list))))))

  ;; function for removing a tab for a buffer - non-nil argument ensures buffer is killed
  (defun knavemacs/tab-line-drop-tab (&optional kill)
    "Remove the tab for the current buffer. Will KILL indirect buffers, but leave all others open."
    (interactive)
    (let ((buffer-to-drop (current-buffer)))
      (knavemacs/tab-line-switch-before-drop-kill)
      ;;if buffer is indirect, dired, help or kill is non-nil, kill-this-buffer, otherwise remove from tab-list (keeping buffer open)
      (if (or kill
              (buffer-base-buffer buffer-to-drop)
              ;;buffer-file-name is blank for dired and help descriptions, so kill those buffers
              (not (buffer-file-name buffer-to-drop)))
          (kill-buffer buffer-to-drop)
        (setq knavemacs/tab-line-buffers-list (delete buffer-to-drop knavemacs/tab-line-buffers-list))))
    (set-window-parameter nil 'tab-line-cache nil)
    (force-mode-line-update))

  ;; convieneince function for killing a buffer/tab
  (defun knavemacs/tab-line-kill-tab ()
    "Kill the buffer and tab active in the tab-line"
    (interactive)
    (knavemacs/tab-line-drop-tab t))


  ;; set the hook to update the tab-line on buffer changes
  (add-hook 'buffer-list-update-hook #'knavemacs/tab-line-add-current-buffer)
#+END_SRC


*** Frame-Window-Buffer Session Management
I have the need to save certain the configuration of my windows, buffers, and layouts as "activities" that I can open quickly later.
There is an excellent package for this, activities, that provides me this functionality.

#+BEGIN_SRC emacs-lisp
  (use-package activities
    :if knavemacs/config-visual
    :init
    (activities-mode)
    (activities-tabs-mode)
    ;; Prevent `edebug' default bindings from interfering.
    (setq edebug-inhibit-emacs-lisp-mode-bindings t)

    :bind
    (("C-x C-a C-n" . activities-new)
     ("C-x C-a C-d" . activities-define)
     ("C-x C-a C-a" . activities-resume)
     ("C-x C-a C-s" . activities-suspend)
     ("C-x C-a C-k" . activities-kill)
     ("C-x C-a RET" . activities-switch)
     ("C-x C-a b" . activities-switch-buffer)
     ("C-x C-a g" . activities-revert)
     ("C-x C-a l" . activities-list)))
#+END_SRC


** File Management
*** Dired Configuration
Some modifications to the dired functionality.

#+BEGIN_SRC emacs-lisp
  (defun knavemacs/dired-mode-setup ()
    (dired-hide-details-mode))

  (use-package dired
    :if knavemacs/config-dired
    :hook (dired-mode . knavemacs/dired-mode-setup)
    :ensure nil
    :commands (dired dired-jump)
    :custom ((dired-listing-switches "-alGh --group-directories-first"))
    :config

    ;; function declaration to create a dired sidebar
    (defun knavemacs/dired-vc-root-left ()
      "This function is taken closely verbatim from Protesilaos Stavrou's dired function.
	    Open the root directory of the current version-controlled repository or the present
	    working directory with `dired` with specific window parameters."
      (interactive)
      (let ((dir (if (eq (vc-root-dir) nil)
		     (dired-noselect default-directory)
		   (dired-noselect (vc-root-dir)))))
	(display-buffer-in-side-window
	 dir `((side . left)
	       (slot . 0)
	       (window-width . 0.2)
	       (window-parameters . (
				     (no-delete-other-windows . t)
				     (mode-line-format . (" "
							  "%b"))))))
	(with-current-buffer dir
	  (rename-buffer "*Dired-Side*"))
	(with-current-buffer dir
	  (tab-line-mode -1)))

      (with-eval-after-load 'ace-window
	(when (boundp 'aw-ignored-buffers)
	  (add-to-list 'aw-ignored-buffers "*Dired-Side*"))))

    ;; function declaraction to have files opened in the next window when pressing "o"
    ;; from https://stackoverflow.com/questions/10073673/open-file-in-specified-window-in-emacs
    (defun dired-window () (window-at (frame-width) 1))
    (eval-after-load 'dired
      '(define-key dired-mode-map (kbd "o")
		   (lambda ()
		     (interactive)
		     (let ((dired-window (dired-window)))
		       (set-window-buffer dired-window
					  (find-file-noselect 
					   (dired-get-file-for-visit)))
		       (select-window dired-window)))))

    ;; function declaration to setup a project-like tab mode style of working with
    ;; a directory tree on the left, and working files under tabs on the right
    (defun knavemacs/tabbed-workspace-with-dired ()
      (interactive)
      (global-tab-line-mode)
      (knavemacs/dired-vc-root-left))
    )

#+END_SRC

*** Additional Dired Functionality
Companion dired packages.

#+BEGIN_SRC emacs-lisp
  ;; PURPOSE: prevents a bunch of dired buffers from accumulating in the buffer list
  (use-package dired-single
    :if knavemacs/config-dired
    )

  ;; PURPOSE: hides hidden files from the default dired view
  (use-package dired-hide-dotfiles
    :if knavemacs/config-dired
    :hook (dired-mode . dired-hide-dotfiles-mode))

  ;; PURPOSE: allows viewing the contents of a subdirectory, without changing the current dired view
  (use-package dired-subtree
    :if knavemacs/config-dired
    )
#+END_SRC


** Productivity & Notetaking
*** Org Mode
There's a lot to unpack here, and this tends to be tweaked from time to time.
Required folder setup is indicated in the Installation section at the beginning
of this document.

#+BEGIN_SRC emacs-lisp
;; PURPOSE: this manages my getting things done workflow during work
(defun knavemacs/org-mode-setup ()
  (org-indent-mode))

(use-package org
  :if knavemacs/config-org
  :hook (org-mode . knavemacs/org-mode-setup)
  :custom
  (setq org-cite-global-bibliography '("~/Documents/knowledge/master.bib"))
  (setq org-cite-export-processors
   '((latex biblatex)))

  :config
  (setf (cdr (rassoc 'find-file-other-window org-link-frame-setup)) 'find-file) ; open links in same buffer
  (setq org-agenda-files (list "~/Documents/org" "~/Documents/org/active"))
  (setq org-agenda-todo-list-sublevels nil) ;; only want to see top level TODOs in global list
  (setq org-stuck-projects
        '("+LEVEL=3+PROJECT/-DONE" ("NEXT")))
  (setq org-refile-targets
        '((nil :maxlevel . 1)
          (org-agenda-files :maxlevel . 2)))
  (setq org-todo-keywords
        '((sequence "TODO(t)" "BACKLOG(b@/!)" "PROJ(p)" "NEXT(x)" "HOLD(h@/!)" "FEEDBACK(f@/!)" "|" "DONE(d!)" "CANCELED(c)")
          (sequence "NOTICE(n)" "|" "RESOLVED(r@)")
          (sequence "NOTE(e)" "|" "NOTED(z)" "TRASH(x)")
          ))
  (setq org-todo-keywoard-faces
        '(("TODO" . "green") ("BACKLOG" . "red") ("NEXT" . "green") ("HOLD" . "yellow") 
          ("DONE" . "blue") ("CANCELED" . "purple") ("NOTE" . org-warning) ("NOTED" . "green")))

  ;; custom agenda views
  (setq org-agenda-custom-commands
        '(("d" "Work-Week Dashboard"
           (
            (todo "NOTICE" ((org-agenda-overriding-header "Notices for Today")))
            (agenda "" ((org-deadline-warning-days 7)))
            (tags "PROJECT+TODO=\"NEXT\"|-PROJECT+TODO=\"TODO\""
                       ((org-agenda-overriding-header "Activities to Schedule")
                        (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled))))
            (todo "FEEDBACK" ((org-agenda-overriding-header "Items Requiring Feedback")))
            ))
          ("f" "View Fleeting Notes Collection"
           (
            (todo "NOTE" ((org-agenda-overriding-header "Fleeting Notes")))
            )))
        )

  ;; capture templates
  (setq org-capture-templates
        '(
          ("n" "Post Notice" entry (file+olp "~/Documents/org/notice.org" "Notice")
           "* NOTICE %?\n%U Notice Created" :empty-lines 1)

          ("m" "Meeting Notes" entry (file+olp "~/Documents/org/meetings.org" "Unfiled Meeting Notes")
           "* %t %^{Enter Meeting Title} :Clarify:%^G \n** Attendees\n*** \n** Notes\n*** \n** Action Items\n*** TODO " :tree-type week :clock-in t :clock-resume t :empty-lines 0)

          ("t" "New Todo" entry (file+olp "~/Documents/org/todos.org" "TODOs")
           "* TODO [#A] %^{Enter TODO Item} :Clarify:\n %?" :empty-lines 1)

          ("z" "New Work File" entry (file "~/Documents/org/new.org")
           "* Backlog\n* Meetings\n* Knowledge\nBe sure to add FILETAGS to the new file.\n%i")

          ("f" "Fleeting Note" entry (file+olp "~/Documents/org/fleeting.org" "Fleeting Notes")
           "* NOTE %?\n %i" :empty-lines 1)
          ))
  )
#+END_SRC


** Programming Configurations
*** Indentation
Here are my tab / indentation configurations:

#+BEGIN_SRC emacs-lisp
  (defun coding-hooks ()
    (setq c-basic-offset 4)
    (setq-default tab-width 4)
    (c-set-offset 'substatement-open 0)
    (c-set-offset 'brace-list-open 0)
    (c-set-offset 'block-open 0)
    (c-set-offset 'class-open 0)
    (c-set-offset 'inline-open 0)
    (c-toggle-hungry-state 1)
    (local-set-key "\M-a" 'paren-backward-sexp)
    (local-set-key "\M-e" 'paren-forward-sexp)
    (local-set-key "\C-\M-h" 'hs-hide-all)
    (hs-minor-mode t)
    (abbrev-mode 0)
    (add-hook 'before-save-hook 'coding-system-hook)
    )
  (add-hook 'c++-mode-hook 'coding-hooks)
  (add-hook 'c-mode-hook 'coding-hooks)
#+END_SRC

*** Snippets
Yasnippets is the defacto standard for Emacs imo.

#+BEGIN_SRC emacs-lisp
  ;; yasnippet snippets engine
  (use-package yasnippet
    :if knavemacs/config-snippets
    :config
    (setq yas-snippet-dirs
	  '("~/Shelf/snippets"))
    (yas-global-mode 1) ;; or M-x yas-reload-all if YASnippet is already started
    )
#+END_SRC

*** Version Control
Some minor tweaks for magit.

#+BEGIN_SRC emacs-lisp
  ;; PURPOSE: git interface with emacs
  (use-package magit
    :if knavemacs/config-programming
    :init
    (if (eq system-type 'windows-nt) (setq exec-path (append exec-path '("C:/Users/josinski/auxiliary/other/lsys/cmder/vendor/git-for-windows/bin"))))
    )
#+END_SRC


** Keybindings and Navigation
*** Jump-To-Location
Avy is a swiss army knife of jumping to a specific location!

#+BEGIN_SRC emacs-lisp
  ;; Install Avy - jump to location based on char decision tree
  (use-package avy
    :if knavemacs/config-keybinds
    :config

    ;; define an avy action to kill a while line based on a selection
    ;; (see https://karthinks.com/software/avy-can-do-anything/)
    (defun avy-action-kill-whole-line (pt)
      (save-excursion
	(goto-char pt)
	(kill-whole-line))
      (select-window
       (cdr
	(ring-ref avy-ring 0)))
      t)

    ;; define an avy action to activate embark on a selection
    (defun avy-action-embark (pt)
      (save-excursion
	(goto-char pt)
	(embark-act))
      (select-window
       (cdr
	(ring-ref avy-ring 0)))
      t)

    ;; add custom avy actions to the action dispatcher
    (setf (alist-get ?K avy-dispatch-alist) 'avy-action-kill-whole-line
	  (alist-get ?o avy-dispatch-alist) 'avy-action-embark)
    )
#+END_SRC

*** Window Navigation
Ace Window is a great extension for quick navigation of windows!

#+BEGIN_SRC emacs-lisp
  ;; Ace Window for quick window navigation
  (use-package ace-window
    :if knavemacs/config-keybinds
    :config
    ;; defines hot keys to use for window switching
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
#+END_SRC

*** Custom Transient Functions
I am using the built in transient functions for quick menus and "hydra" like
multi-key press functionality.

#+BEGIN_SRC emacs-lisp
  ;; custom transient menus and functionality
  (transient-define-prefix knavemacs/transient-org-commands ()
    "Custom Org Commands Transient"
    :info-manual "Custom Org Commands Transient"
    ["Org-Mode Actions"
     ("a" "Org Agenda" org-agenda)
     ("c" "Org Capture" org-capture)
     ("l" "Store Link" org-store-link)]
    [("q" "Quit" transient-quit-one)])

  (transient-define-prefix knavemacs/transient-note-commands ()
    "Custom Org-Roam Commands Transient"
    :info-manual "Custom Note-Taking Commands Transient"
    [["Note-Taking Actions"
      ("f" "Create/Find a Note" org-roam-node-find)
      ("b" "Show Linked Notes Buffer" org-roam-buffer-toggle)
      ("l" "Insert Link to Note" org-roam-node-insert)]
     ["View Specific Notes"
      ("L" "View Literature Notes" knavemacs/org-roam-node-find-literature-only)
      ("T" "View Notes with Tag" knavemacs/org-roam-find-by-tag)]]
    [["Miscellaneous Actions"
      ("E" "Launch Ebib" ebib)
      ("q" "Quit" transient-quit-one)]
     ["Citation Actions"
      ("cf" "Open Note from Biblio" citar-open-notes)
      ("ci" "Insert Biblio Citation" citar-insert-citation)]])

  (transient-define-prefix knavemacs/transient-saveclose-commands ()
    "Custom Save and Close Commands Transient"
    :info-manual "Custom Save and Close Commands Transient"
    ["Choose Action"
     ("Z" "Save All and Close" save-buffers-kill-terminal)
     ("Q" "Kill Emacs" kill-emacs)]
    [("q" "Quit" transient-quit-one)])

  (transient-define-prefix knavemacs/transient-buffer-commands ()
    "Custom Buffer Commands Transient"
    :info-manual "Custom Buffer Commands Transient"
    ["Buffer Actions"
     ("b" "Switch To Buffer" consult-buffer)
     ("k" "Kill Buffer" kill-current-buffer)
     ("K" "Kill Some Buffer" kill-buffer)
     ("u" "See Undo Tree" vundo)]
    [("q" "Quit" transient-quit-one)])

  (transient-define-prefix knavemacs/transient-tab-line-commands ()
    "Custom Tab Line Commands Transient"
    :info-manual "Custom Tab Line Commands Transient"
    ["Tab Line Actions"
     ("n" "Next Tab" tab-line-switch-to-next-tab)
     ("p" "Prev Tab" tab-line-switch-to-prev-tab)
     ("d" "Drop Tab" knavemacs/tab-line-drop-tab)
     ("k" "Kill Buffer Tab" knavemacs/tab-line-kill-tab)]
    [("q" "Quit" transient-quit-one)])

#+END_SRC

*** Modal Editing
I use the meow package as my modal editing system. Lots of customizations here
to mirror many aspects of vim (and others) that I really enjoy, while keeping
the spirit of Emacs intact.

#+BEGIN_SRC emacs-lisp
  ;; custom functions and menus used in my modal editing config
    ;; scroll half a screen
  (defun knavemacs/scroll-down-half-page ()
    "scroll down half a page while keeping the cursor centered"
    (interactive)
    (let ((ln (line-number-at-pos (point)))
          (lmax (line-number-at-pos (point-max))))
      (cond ((= ln 1) (move-to-window-line nil))
            ((= ln lmax) (recenter (window-end)))
            (t (progn
                 (move-to-window-line -1)
                 (recenter))))))

  (defun knavemacs/scroll-up-half-page ()
    "scroll up half a page while keeping the cursor centered"
    (interactive)
    (let ((ln (line-number-at-pos (point)))
          (lmax (line-number-at-pos (point-max))))
      (cond ((= ln 1) nil)
            ((= ln lmax) (move-to-window-line nil))
            (t (progn
                 (move-to-window-line 0)
                 (recenter))))))

  ;; combined meow actions
  (defun knavemacs/meow-append-end-line ()
    "go directly to the end of a line to append additional text"
    (interactive)
    (call-interactively 'meow-line)
    (call-interactively 'meow-append))

  (defun knavemacs/meow-insert-beginning-line ()
    "go directly to the beginning of a line to append additonal text"
    (interactive)
    (call-interactively 'meow-line)
    (call-interactively 'meow-insert))

  ;; shift cursor position functions
  (defun knavemacs/recenter-top ()
    "Recenter View to Top"
    (interactive)
    (recenter-top-bottom 0))

  (defun knavemacs/recenter-bottom ()
    "Recenter View to Bottom"
    (interactive)
    (recenter-top-bottom -1))

  ;; some prefix keymaps I use in meow normal mode
  (defvar-keymap meow-z-prefix-map
    :doc "Provide's Quick z key commands using meow"
    "z" #'recenter
    "t" #'knavemacs/recenter-top
    "b" #'knavemacs/recenter-bottom)

  ;; modal editing keybind configuration
  (use-package meow
      :if knavemacs/config-keybinds
    :diminish
    :config
    (defun meow-setup ()
      (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)

      ; overwrites while in motion mode
      (meow-motion-overwrite-define-key
       '("j" . meow-next)
       '("k" . meow-prev)
       '("h" . meow-left)
       '("l" . meow-right)
       ;; C-M-* will run the original command in MOTION state.
       '("C-M-j" . "H-j")
       '("C-M-k" . "H-k")
       '("C-M-h" . "H-h")
       '("C-M-l" . "H-l")
       '("<escape>" . ignore))

      ; definitions active when pressing leader (i.e. space)
      (meow-leader-define-key
       ;; Space-# is now used for number expansion
       '("0" . meow-expand-0)
       '("9" . meow-expand-9)
       '("8" . meow-expand-8)
       '("7" . meow-expand-7)
       '("6" . meow-expand-6)
       '("5" . meow-expand-5)
       '("4" . meow-expand-4)
       '("3" . meow-expand-3)
       '("2" . meow-expand-2)
       '("1" . meow-expand-1)

       '("r" . rectangle-mark-mode)
       '("o" . knavemacs/transient-org-commands)
       ;'("n" . knavemacs/transient-note-commands)
       '("t" . knavemacs/transient-tab-line-commands)
       '("b" . knavemacs/transient-buffer-commands)
       '("w" . ace-window)
       '("?" . meow-keypad-describe-key))

      ; normal mode definitions
      (meow-normal-define-key
       '("1" . meow-digit-argument)
       '("2" . meow-digit-argument)
       '("3" . meow-digit-argument)
       '("4" . meow-digit-argument)
       '("5" . meow-digit-argument)
       '("6" . meow-digit-argument)
       '("7" . meow-digit-argument)
       '("8" . meow-digit-argument)
       '("9" . meow-digit-argument)
       '("0" . meow-digit-argument)
       '("-" . delete-other-windows)
       '("_" . delete-window)
       '("=" . split-window-below)
       '("+" . split-window-right)
       '("{" . meow-beginning-of-thing)
       '("}" . meow-end-of-thing)
       '("[" . meow-inner-of-thing)
       '("]" . meow-bounds-of-thing)
       '("%" . meow-block)
       '(";" . meow-reverse)
       '("," . move-beginning-of-line)
       '("." . move-end-of-line)
       '("(" . tab-line-switch-to-prev-tab)
       '(")" . tab-line-switch-to-next-tab)

       '("a" . meow-append)
       '("A" . knavemacs/meow-append-end-line)
       '("b" . meow-back-word)
       '("B" . meow-back-symbol)
       '("c" . meow-change)
       ;'("C" . )
       '("d" . meow-kill)
       '("D" . meow-kill-whole-line)
       '("e" . meow-next-word)
       '("E" . meow-next-symbol)
       '("f" . meow-find)
       ;'("F" . )
       '("g" . meow-cancel-selection)
       '("G" . meow-pop-selection)
       '("h" . meow-left)
       '("H" . meow-left-expand)
       '("i" . meow-insert)
       '("I" . knavemacs/meow-insert-beginning-line) 
       '("j" . meow-next)
       '("J" . meow-next-expand)
       '("k" . meow-prev)
       '("K" . meow-prev-expand)
       '("l" . meow-right)
       '("L" . meow-right-expand)
       '("N" . avy-goto-char-timer)
       '("n" . meow-search)
       '("M" . meow-grab)
       '("m" . meow-join)
       '("o" . meow-open-below)
       '("O" . meow-open-above)
       '("p" . meow-yank)
       '("q" . meow-quit)
       '("r" . meow-replace)
       '("R" . query-replace)
       '("s" . meow-line)
       '("S" . meow-goto-line)
       '("t" . meow-till)
       '("u" . meow-undo)
       '("U" . undo-redo)
       '("v" . knavemacs/scroll-down-half-page)
       '("V" . knavemacs/scroll-up-half-page)
       '("w" . meow-mark-word)
       '("W" . meow-mark-symbol)
       '("x" . meow-delete)
       '("X" . meow-backward-delete)
       '("y" . meow-save)
       '("Y" . meow-sync-grab)
       ;'("z" . meow-z-prefix-map) - see below
       '("Z" . knavemacs/transient-saveclose-commands)
       '("'" . repeat)
       '("<escape>" . ignore)
       '("/" . meow-visit)
       '("<" . beginning-of-buffer)
       '(">" . end-of-buffer)
       ))

    (meow-setup)
    (meow-global-mode 1)

    ;; custom configuration for cursor types
    (setq meow-cursor-type-default 'hollow)
    (setq meow-cursor-type-normal 'hollow)
    (setq meow-cursor-type-motion 'hollow)
    (setq meow-cursor-type-insert 'box)
    (setq meow-cursor-type-keypad 'hollow)
    
    ;; attach the custom z keymap to the z key in normal mode
    (meow-define-keys
        'normal
      (cons "z" meow-z-prefix-map))
    )
#+END_SRC

*** Overall Keymap Changes
Given all the above, I make a few final overall changes to my keybindings

#+BEGIN_SRC emacs-lisp
  ;; global
  ;; I opt to put my global keymaps into a custom minor mode
  ;; Good reference for the reasoning why: https://emacs.stackexchange.com/questions/27926/avoiding-overwriting-global-key-bindings
  (define-minor-mode knavemacs-mode
    "Custom minor mode for Knavemacs global keymaps"
    ;; enable by default
    1
    ;; mode indicator
    " Knavemacs"
    ;; minor mode keymap
    '(
      ("\M-m" . meow-global-mode) ; global toggle key for meow modal editing
      ("\M-o" . ace-window) ; quick key for window changes, so I can do this in insert mode too
      ("\M-0" . tab-bar-switch-to-next-tab)
      ("\M-9" . tab-bar-switch-to-prev-tab)
      ("\M-8" . kmacro-call-macro)
      ("\M-6" . kmacro-start-macro)
      ("\M-7" . kmacro-end-macro)
      ("\M-L" . enlarge-window-horizontally)
      ("\M-K" . shrink-window)
      ("\M-J" . enlarge-window)
      ("\M-H" . shrink-window-horizontally)
      ("\M-l" . windmove-right)
      ("\M-k" . windmove-up)
      ("\M-j" . windmove-down)
      ("\M-h" . windmove-left)
    )
    ;; make global vs buffer specific
    :global 1)

  ;; general global remaps
  (define-key global-map "\M-ss" 'consult-line) ; remap this from recommended consult maps to keep this under M-s
  (define-key global-map "\C-x\C-b" 'ibuffer) ; remap buffer list to interactive list
  (define-key global-map "\C-cp" project-prefix-map) ; remap project commands so I can use <spc>-p with meow
  (define-key global-map "\C-x\C-t" tab-prefix-map) ; remap tabbar commands from C-x t to C-x C-t for better use with keypad
  (define-key global-map "\C-xt" 'transpose-lines) ; switch the original C-x C-t command per the above

  ;; project map changes
  (define-key project-prefix-map "V" 'project-vc-dir)
  (define-key project-prefix-map "v" 'magit-status)
  (define-key project-prefix-map "\C-b" 'consult-project-buffer) ;; use over project-switch-to-buffer
  (define-key project-prefix-map "t" 'knavemacs/dired-vc-root-left) ;; show project tree
  (define-key project-prefix-map "T" 'knavemacs/tabbed-workspace-with-dired) ;; enable tab-line, open new tabs with dired

  ;; dired configurations
  ;; note, <space>-j to jump (dired-goto-file) in dired buffers
  ;; note, <space>-x-j to open current buffer location in dired for other buffers
  ;; note, o to open file in a different buffer split for editing (vs Enter)
  ;; note, C-o to open file in a differnet buffer split, keep focus on dired
  (define-key dired-mode-map "h" 'dired-single-up-directory)
  (define-key dired-mode-map "l" 'dired-single-buffer)
  (define-key dired-mode-map "K" 'dired-do-kill-lines)
  (define-key dired-mode-map "H" 'dired-hide-dotfiles-mode)
  (define-key dired-mode-map ";" 'dired-subtree-toggle)
#+END_SRC
